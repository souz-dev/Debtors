/**
 * Parses a brazilian formatted list into an Array.
 * @example
 * parseToArray('');
 * //=> []
 * parseToArray('1');
 * //=> ['1']
 * parseToArray('1 e 2');
 * //=> ['1', '2']
 * parseToArray('1, 2, 3, 4 e 5');
 * //=> ['1', '2', '3', '4', '5']
 * parseToArray('Fernanda, Luana e Ana Carolina');
 * //=> ['Fernanda', 'Luana', 'Ana Carolina']
 * @param value - A brazilian formatted list.
 */
var parseToArray = function parseToArray(value) {
  if (!value.trim()) return [];
  var items = value.split(' e ');
  if (items.length === 1) return items;
  return items[0].split(', ').concat(items[1]);
};

/**
 * Transforms pieces of a date into a Date instance.
 * @param pieces - Date pieces.
 */
var parsePiecesToDate = function parsePiecesToDate(pieces) {
  return new Date(pieces.year, pieces.month, pieces.date, pieces.hours, pieces.minutes, pieces.seconds);
};

/**
 * Compare pieces of a date to values obtained from a Date instance.
 * @param pieces - Pieces of a date (date, month, year, hours, minutes and seconds).
 * @param instance - A Date instance.
 */

var comparePiecesToDate = function comparePiecesToDate(pieces, instance) {
  if (instance === void 0) {
    instance = parsePiecesToDate(pieces);
  }

  return instance.getDate() === pieces.date && instance.getMonth() === pieces.month && instance.getFullYear() === pieces.year && instance.getHours() === pieces.hours && instance.getMinutes() === pieces.minutes && instance.getSeconds() === pieces.seconds;
};

/**
 * Resolve a brazilian formatted date or datetime into date, month, year  pieces and hours, minutes and seconds pieces (if contains time).
 * @param value - A date in DD/MM/YYYY or DD/MM/YYYY HH:mm:ss.
 */
var mapToPieces = function mapToPieces(value) {
  var expression = /^(\d{2})\/(\d{2})\/(\d{4})( (\d{2}):(\d{2})(:(\d{2}))?)?$/;

  var _a = expression.exec(value),
      DD = _a[1],
      MM = _a[2],
      YYYY = _a[3],
      HH = _a[5],
      mm = _a[6],
      ss = _a[8];

  return {
    date: parseInt(DD, 10),
    year: parseInt(YYYY, 10),
    month: parseInt(MM, 10) - 1,
    hours: parseInt(HH !== null && HH !== void 0 ? HH : 0, 10),
    minutes: parseInt(mm !== null && mm !== void 0 ? mm : 0, 10),
    seconds: parseInt(ss !== null && ss !== void 0 ? ss : 0, 10)
  };
};

/**
 * A `RegExp` that matches common brazilian date and, optionally, time formats.
 *
 * In date and time the seconds are optional too. So the valid formats are:
 * "DD/MM/YYYY", "DD/MM/YYYY HH:mm" and "DD/MM/YYYY HH:mm:ss".
 */

var DATE_TIME_PATTERN = /^\d{2}\/\d{2}\/\d{4}( \d{2}:\d{2}(:\d{2})?)?$/;
/**
 * Parses a brazilian formatted date into a Date instance.
 * @example ```js
 * parseToDate('28/03/1996')
 * //=> '1996-03-28T03:00:00.000Z'
 *
 * parseToDate('31/02/2018')
 * //=> throws Error('Value "31/02/2018" is an invalid date.')
 * ```
 * @param value - A date in DD/MM/YYYY.
 */

var parseToDate = function parseToDate(value) {
  if (!DATE_TIME_PATTERN.test(value)) throw new Error("Value \"" + value + "\" does not match format.");
  var pieces = mapToPieces(value);
  var instance = parsePiecesToDate(pieces);
  if (!comparePiecesToDate(pieces, instance)) throw new Error("Value \"" + value + "\" is an invalid date.");
  return instance;
};

/**
 * Parses brazilian formatted number to number.
 * @example
 * parseToNumber('10')
 * //=> 10
 * parseToNumber('-1.299')
 * //=> -1299
 * parseToNumber('0,981')
 * //=> 0.981
 * parseToNumber('19.898,1298')
 * //=> 19898.1298
 * @param value - A brazilian formatted number.
 */
var parseToNumber = function parseToNumber(value) {
  return Number(value.replace(/\./g, '').replace(',', '.'));
};

/**
 * Pattern to match formatted CEP (99999-999) or 8 numbers.
 */
var CEP_PATTERN = /^(\d{8}|\d{2}\.?\d{3}\-\d{3})$/;
/**
 * Check if value is a valid CEP.
 * @example ```js
 * isCEP('50.833-000')
 * //=> true
 *
 * isCEP('02998-050')
 * //=> true
 *
 * isCEP('00000000')
 * //=> true
 *
 * isCEP('0')
 * //=> false
 *
 * isCEP('1982891928981982198')
 * //=> false
 * ```
 * @param value - A text containing a CEP.
 */

var isCEP = function isCEP(value) {
  return CEP_PATTERN.test(value);
};

/**
 * Generate check sums. Multiply numbers to validators and sum them to generate
 * check sums, they're used to check if numbers are valid.
 * @param numbers - Numbers used to generate checkers.
 * @param validators - Validators used to generate checkers.
 */
var generateCheckSums = function generateCheckSums(numbers, validators) {
  var initialCheckSums = [0, 0];
  return validators.reduce(function (_a, validator, index) {
    var checkerA = _a[0],
        checkerB = _a[1];
    return [index === 0 ? 0 : checkerA + numbers[index - 1] * validator, checkerB + numbers[index] * validator];
  }, initialCheckSums);
};

/**
 * Get remaining of 11 or `0` if lower than 2.
 * @param value - Value used remaining.
 */
var getRemaining = function getRemaining(value) {
  return value % 11 < 2 ? 0 : 11 - value % 11;
};

/**
 * Check if items are same, if their values are repeated.
 * @param item
 */
var isRepeatedArray = function isRepeatedArray(items) {
  return items.every(function (item) {
    return items[0] === item;
  });
};

/**
 * Matches every non-numeric characters.
 */
var NonNumeric = /\D/g;
/**
 * Maps to a text containing only numeric characters.
 * @param value - A text containing numbers.
 */

var mapToNumeric = function mapToNumeric(value) {
  return value.replace(NonNumeric, '');
};

/**
 * Maps a text to a collection of it's numbers.
 * @param value - A text containing numbers.
 */

var mapToNumbers = function mapToNumbers(value) {
  return mapToNumeric(value).split('').map(Number);
};

/**
 * Pattern to match formatted CNPJ (99.999.999/9999-99) or 14 numbers.
 */

var CNPJ_PATTERN = /^(\d{14}|\d{2}\.\d{3}\.\d{3}\/\d{4}\-\d{2})$/;
/**
 * Check if value is a valid CNPJ.
 * @example ```js
 * isCNPJ('41142260000189')
 * //=> true
 *
 * isCNPJ('45.723.174/0001-10')
 * //=> true
 *
 * isCNPJ('411407182')
 * //=> false
 *
 * isCNPJ('11.111.111/1111-11')
 * //=> false
 * ```
 * @param value - A text containing a CNPJ.
 */

var isCNPJ = function isCNPJ(value) {
  if (!CNPJ_PATTERN.test(value)) return false;
  var numbers = mapToNumbers(value);
  if (isRepeatedArray(numbers)) return false;
  var validators = [6, 5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2];
  var checkers = generateCheckSums(numbers, validators);
  return numbers[12] === getRemaining(checkers[0]) && numbers[13] === getRemaining(checkers[1]);
};

/**
 * Pattern to match formatted CPF (999.999.999-99) or 11 numbers.
 */

var CPF_PATTERN = /^(\d{11}|\d{3}\.\d{3}\.\d{3}\-\d{2})$/;
/**
 * Check if value is a valid CPF.
 * @example ```js
 * isCPF('366.418.768-70')
 * //=> true
 *
 * isCPF('36641876870')
 * //=> true
 *
 * isCPF('213.198.013-20')
 * //=> false
 *
 * isCPF('2131201872781')
 * //=> false
 *
 * isCPF('11111111111')
 * //=> false
 * ```
 * @param value - A text containing a CPF.
 */

var isCPF = function isCPF(value) {
  if (!CPF_PATTERN.test(value)) return false;
  var numbers = mapToNumbers(value);
  if (isRepeatedArray(numbers)) return false;
  var validators = [11, 10, 9, 8, 7, 6, 5, 4, 3, 2];
  var checkers = generateCheckSums(numbers, validators);
  return numbers[9] === getRemaining(checkers[0]) && numbers[10] === getRemaining(checkers[1]);
};

/**
 * Pattern to match brazilian formatted dates (99/99/9999).
 */

var DATE_PATTERN = /^\d{2}\/\d{2}\/\d{4}((\s)?(\d{2}:\d{2}:\d{2}))?$/;
/**
 * Check if a brazilian formatted date is valid.
 * @example ```js
 * isDate('03/08/2017')
 * //=> true
 *
 * isDate('28/13/2017')
 * //=> false
 *
 * isDate('03-08-2017')
 * //=> false
 *
 * isDate('31/03/18')
 * //=> false
 * ```
 * @param value - A date in DD/MM/YYYY.
 */

var isDate = function isDate(value) {
  return DATE_PATTERN.test(value) && comparePiecesToDate(mapToPieces(value));
};

/**
 * Brazilian valid DDD (direct dialing at a distance) codes.
 */
var DDDs = ["11", "12", "13", "14", "15", "16", "17", "18", "19", "21", "22", "24", "27", "28", "31", "32", "33", "34", "35", "37", "38", "41", "42", "43", "44", "45", "46", "47", "48", "49", "51", "53", "54", "55", "61", "62", "63", "64", "65", "66", "67", "68", "69", "71", "73", "74", "75", "77", "79", "81", "82", "83", "84", "85", "86", "87", "88", "89", "91", "92", "93", "94", "95", "96", "97", "98", "99"];
/**
 * Check if value is a valid DDD.
 * @example ```js
 * isDDD('81')
 * //=> true
 *
 * isDDD('10')
 * //=> false
 *
 * isDDD('A#')
 * //=> false
 * ```
 * @param code
 */

var isDDD = function isDDD(code) {
  return DDDs.indexOf(code) !== -1;
};

/**
 * Pattern for common brazilian telephone number formats, optionally with DDI,
 * DDD and the ninth digit.
 */

var PHONE_PATTERN = /^(\+55)? ?\(?(\d{2})?\)? ?9? ?\d{4}[-| ]?\d{4}$/;
/**
 * Check if value is a valid brazilian phone number. It can check a wide
 * variety of formats optionally with DDI, DDD and the ninth digit.
 *
 * @example ```js
 * isPhone('+55 (11) 9 8273-1182')
 * //=> true
 *
 * isPhone('11 9 8273 1182')
 * //=> true
 *
 * isPhone('1139723768')
 * //=> true
 *
 * isPhone('(23) 3972-3768')
 * //=> false
 *
 * isPhone('(13) 6 5093-2093')
 * //=> false
 *
 * isPhone('(81) 555 178')
 * //=> false
 * ```
 * @param value
 */

var isPhone = function isPhone(value) {
  if (!PHONE_PATTERN.test(value)) return false;

  var _a = PHONE_PATTERN.exec(value),
      DDD = _a[2];

  return DDD ? isDDD(DDD) : true;
};

var PATTERNS = [CPF_PATTERN, CNPJ_PATTERN];
/**
 * Check if a value is a valid CPF or CNPJ
 * @example ```js
 * isCPFOrCNPJ('366.418.768-70')
 * //=> true
 *
 * isCPFOrCNPJ('36641876870')
 * //=> true
 *
 * isCPFOrCNPJ('213.198.013-20')
 * //=> false
 *
 * isCPFOrCNPJ('2131201872781')
 * //=> false
 *
 * isCPFOrCNPJ('11111111111')
 * //=> false
 *
 * isCPFOrCNPJ('41142260000189')
 * //=> true
 *
 * isCPFOrCNPJ('45.723.174/0001-10')
 * //=> true
 *
 * isCPFOrCNPJ('411407182')
 * //=> false
 *
 * isCPFOrCNPJ('11.111.111/1111-11')
 * //=> false
 * ```
 * @param value - A text containing a CPF or CNPJ
 */

var isCPFOrCNPJ = function isCPFOrCNPJ(value) {
  var matches = PATTERNS.map(function (pattern) {
    return pattern.test(value);
  });
  if (!matches.includes(true)) return false;
  return matches[0] ? isCPF(value) : isCNPJ(value);
};

/**
 * Add periods to a numeric string value.
 * @param value - A numeric string value.
 */
var addPeriods = function addPeriods(value) {
  return value.replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1.');
};

/**
 * Formats a number into money (BRL) format.
 * @example ```js
 * formatToBRL(1928.93)
 * //=> 'R$ 1.928,93'
 *
 * formatToBRL('9211928.18203')
 * //=> 'R$ 9.211.928,18'
 *
 * formatToBRL(-18.49)
 * //=> 'R$ -18,49'
 * ```
 * @param value BRL value.
 */

var formatToBRL = function formatToBRL(value) {
  var number = Number(value).toFixed(2).replace('.', ',');
  return 'R$ ' + addPeriods(number);
};

/**
 * Capitalizes a word.
 * @param word - A `string` (word) to be capitalized.
 */
var capitalizeWord = function capitalizeWord(word) {
  return word.charAt(0).toLocaleUpperCase() + word.substr(1).toLocaleLowerCase();
};

/**
 * Normalize white spaces in a `string` (value).
 * @param value - A `string` to be normalized.
 */
var normalizeWhiteSpaces = function normalizeWhiteSpaces(value) {
  return value.trim().replace(/\s+/g, ' ');
};

/**
 * Splits text into words.
 * @param text - A `string` to be splitted into words.
 */
var splitIntoWords = function splitIntoWords(text) {
  return text ? text.split(/\s+/) : [];
};

/**
 * A list of default words to keep upper case.
 */

var DEFAULT_WORDS_TO_KEEP_UPPER_CASE = ['cnpj', 'cpf', 'ltda', 'qp', 'tv'];
/**
 * A list of default words to keep lower case.
 */

var DEFAULT_WORDS_TO_KEEP_LOWER_CASE = ['a', 'com', 'da', 'das', 'de', 'do', 'dos', 'e', 'em', 'i', 'na', 'nas', 'no', 'nos', 'o', 'por', 'sem', 'u'];
/**
 * Capitaliza as palavras de um texto, com exceção das palavras configuradas
 * para serem deixadas em caixa-alta ou em caixa-baixa (menos a primeira palavra
 * que não será caixa-baixa mesmo se configurada como).
 *
 * @example ```js
 * formatToCapitalized('SERVIDOR PÚBLICO MUNICIPAL')
 * //=> 'Servidor Público Municipal'
 *
 * formatToCapitalized('   os PrimEIROS  HOMens da tERra', {
 *   wordsToKeepLowerCase: ['os', 'da']
 * })
 * //=> 'Os Primeiros Homens da Terra'
 *
 * formatToCapitalized('nova tv foi lançada', {
 *   wordsToKeepUpperCase: ['tv']
 * })
 * //=> 'Nova TV Foi Lançada'
 *
 * formatToCapitalized(' com espaços antes e depois ', {
 *   trimTrailingWhiteSpaces: false
 * })
 * //=> ' Com Espaços Antes e Depois '
 * ```
 * @param value - A `string` to capitalize
 */

var formatToCapitalized = function formatToCapitalized(value, _a) {
  var _b = _a === void 0 ? {} : _a,
      _c = _b.wordsToKeepLowerCase,
      wordsToKeepLowerCase = _c === void 0 ? DEFAULT_WORDS_TO_KEEP_LOWER_CASE : _c,
      _d = _b.wordsToKeepUpperCase,
      wordsToKeepUpperCase = _d === void 0 ? DEFAULT_WORDS_TO_KEEP_UPPER_CASE : _d,
      _e = _b.trimTrailingWhiteSpaces,
      trimTrailingWhiteSpaces = _e === void 0 ? true : _e;

  return splitIntoWords(trimTrailingWhiteSpaces ? normalizeWhiteSpaces(value) : value).map(function (word, index, words) {
    var isFirstWord = word && index === 0 || !words[0] && index === 1;
    var wordInLowerCase = word.toLocaleLowerCase();
    if (!isFirstWord && wordsToKeepLowerCase.indexOf(wordInLowerCase) !== -1) return wordInLowerCase;
    if (wordsToKeepUpperCase.indexOf(wordInLowerCase) !== -1) return word.toLocaleUpperCase();
    return capitalizeWord(word);
  }).join(" ");
};

/**
 * Format a `string` number sequence into CEP format.
 * @example ```js
 * formatToCEP('15998030')
 * //=> '15998-030'
 *
 * formatToCEP('02999')
 * //=> '02999'
 * ```
 * @param value A `string` with CEP numbers.
 */

var formatToCEP = function formatToCEP(value) {
  return mapToNumeric(value).replace(/(\d{5})(\d{1,3})/, '$1-$2');
};

/**
 * Formats step-by-step a `string` value into a CPF.
 * @example ```js
 * formatToCNPJ('128781')
 * //=> '12.878.1'
 *
 * formatToCNPJ('32284981000138')
 * //=> '32.284.981/0001-38'
 *
 * formatToCNPJ('00.0.000.00.00--00-00')
 * //=> '00.000.000/0000-00'
 * ```
 * @param value - A `string` value of a CNPJ.
 */

var formatToCNPJ = function formatToCNPJ(value) {
  return mapToNumeric(value).replace(/(\d{2})(\d)/, '$1.$2').replace(/(\d{3})(\d)/, '$1.$2').replace(/(\d{3})(\d)/, '$1/$2').replace(/(\d{4})(\d{1,2})$/, '$1-$2');
};

/**
 * Formats step-by-step a `string` value into a CPF.
 * @example ```js
 * formatToCPF('00000000')
 * //=> '000.000.00'
 *
 * formatToCPF('00000000000')
 * //=> '000.000.000-00'
 *
 * formatToCPF('366.418.768-70')
 * //=> '366.418.768-70'
 * ```
 * @param value - A `string` value of a CPF.
 */

var formatToCPF = function formatToCPF(value) {
  return mapToNumeric(value).replace(/(\d{3})(\d)/, '$1.$2').replace(/(\d{3})(\d)/, '$1.$2').replace(/(\d{3})(\d{1,2})$/, '$1-$2');
};

/**
 * Check if a `string` value can be formatted to CPF.
 * @param value - A `string` value of a CPF or CNPJ.
 */

var canFormatToCPF = function canFormatToCPF(value) {
  var _a, _b;

  return ((_b = (_a = value.match(/\d/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) <= 11;
};
/**
 * Formats step-by-step a `string` value to CPF or CNPJ depending on its length.
 * @example
 * formatToCPFOrCNPJ('00000000')
 * //=> '000.000.00'
 *
 * formatToCPFOrCNPJ('366.418.768-70')
 * //=> '366.418.768-70'
 *
 * formatToCPFOrCNPJ('32284981000138')
 * //=> '32.284.981/0001-38'
 *
 * formatToCPFOrCNPJ('00.0.000.00.00--00-00')
 * //=> '00.000.000/0000-00'
 * @param value - A `string` value of a CPF or CNPJ.
 */


var formatToCPFOrCNPJ = function formatToCPFOrCNPJ(value) {
  return canFormatToCPF(value) ? formatToCPF(value) : formatToCNPJ(value);
};

/**
 * Fills a number with zeros.
 * @param value - A number value.
 * @param length - Number of characters to be filled with zeros.
 */
var fillWithZeros = function fillWithZeros(value, length) {
  var numbers = value.toString(10);

  while (numbers.length < length) {
    numbers = '0' + numbers;
  }

  return numbers;
};

/**
 * Formats a Date instance to brazilian format, DD/MM/YYYY.
 * @example ```js
 * formatToDate(new Date(2002, 7, 21))
 * //=> '21/08/2002'
 *
 * formatToDate(new Date())
 * //=> '08/09/2018'
 * ```
 * @param value - A Date instance.
 */

var formatToDate = function formatToDate(value) {
  return fillWithZeros(value.getDate(), 2) + '/' + fillWithZeros(value.getMonth() + 1, 2) + '/' + fillWithZeros(value.getFullYear(), 4);
};

/**
 * Formats a Date instance to brazilian format of date and time, DD/MM/YYYY HH:mm.
 * @example ```js
 * formatToDateTime(new Date(2002, 7, 21, 18, 30))
 * //=> '21/08/2002 18:30'
 * ```
 * @param value - A Date instance.
 */

var formatToDateTime = function formatToDateTime(value) {
  return formatToDate(value) + ' ' + fillWithZeros(value.getHours(), 2) + ':' + fillWithZeros(value.getMinutes(), 2);
};

/**
 * Split `Array` elements into every but last and last element.
 * @param value - An Array with at least one item.
 */
var splitOnLast = function splitOnLast(value) {
  return [value.slice(0, value.length - 1), value[value.length - 1]];
};

/**
 * Formats an Array into brazilian formatted list.
 * @example
 * formatToList(['Vitor', 'William', 'Fernando'])
 * //=> 'Vitor, William e Fernando'
 *
 * formatToList([])
 * // => ''
 *
 * formatToList(['1', '2'])
 * // => '1 e 2'
 *
 * formatToList(['Direito Civil'])
 * //=> 'Direito Civil'
 * @param value - An array of string values.
 */

var formatToList = function formatToList(value) {
  if (value.length === 0) return '';
  if (value.length === 1) return value[0];

  var _a = splitOnLast(value),
      everyButLast = _a[0],
      last = _a[1];

  return everyButLast.join(', ') + ' e ' + last;
};

/**
 * Formats a number to brazilian formatted number.
 * @example
 * formatToNumber(0)
 * //=> '0'
 * formatToNumber(-1299)
 * //=> '-1.299'
 * formatToNumber(.981)
 * //=> '0,981'
 * formatToNumber('19898.1298')
 * //=> '19.898,1298'
 * @param value - Number value to be formatted.
 */

var formatToNumber = function formatToNumber(value) {
  var _a = Number(value).toString(10).split('.'),
      number = _a[0],
      trunc = _a[1];

  if (!trunc) return addPeriods(number);
  return addPeriods(number) + ',' + trunc;
};

/**
 * Formats a phone value into brazilian common phone formats.
 * @example ```js
 * formatToPhone('11')
 * //=> '(11'
 *
 * formatToPhone('11971626')
 * //=> '(11) 9716-26'
 *
 * formatToPhone('11971626799')
 * //=> '(11) 9 7162-6799'
 * ```
 * @param value
 */

var formatToPhone = function formatToPhone(value) {
  return mapToNumeric(value).replace(/(\d{1,2})/, '($1').replace(/(\(\d{2})(\d{1,4})/, '$1) $2').replace(/( \d{4})(\d{1,4})/, '$1-$2').replace(/( \d{1})(\d{3})(?:-)(\d{1})(\d{4})/, '$1 $2$3-$4');
};

/**
 * Progressively formats a `string` into a RG.
 * @example ```js
 * formatToRG('00000000A', 'SP')
 * //=> '00.000.000-A'
 *
 * formatToRG('00.00.0000-0', 'RJ')
 * //=> '00.000.000-0'
 *
 * formatToRG('MG-14.808.688', 'MG')
 * //=> 'MG-14.808.688'
 * ```
 * @param value - A `string` representing an RG.
 * @param state - Brazilian state which defines RG format.
 */
var formatToRG = function formatToRG(value, state) {
  return state !== 'RJ' && state !== 'SP' ? value : value.toUpperCase().replace(/[^\d|A|B|X]/g, '').replace(/(\d{2})(\d)/, '$1.$2').replace(/(\d{3})(\d)/, '$1.$2').replace(/(\d{3})([\d|A|B|X]{1})$/, '$1-$2');
};

/**
 * Formats a phone value into brazilian common phone formats.
 * @example ```js
 * formatToGenericPhone('23456789')
 * //=> '2345-6789'
 *
 * formatToGenericPhone('923456789')
 * //=> '92345-6789'
 *
 * formatToGenericPhone('21923456789')
 * //=> '(21) 92345-6789'
 *
 * formatToGenericPhone('021923456789')
 * //=> '021 92345-6789'
 *
 * formatToGenericPhone('5521923456789')
 * //=> '+55 21 92345-6789'
 * ```
 * @param value
 * @param countryCodeLength
 */

var formatToGenericPhone = function formatToGenericPhone(value,
/*
  Brazil country code: +55
*/
countryCodeLength) {
  if (countryCodeLength === void 0) {
    countryCodeLength = 2;
  }

  var phone = mapToNumeric(value);

  if (phone.length === 8) {
    return phone.replace(/(^\d{4})(\d{4}$)/gi, "$1-$2");
  }

  if (phone.length === 9) {
    return phone.replace(/(^\d{5})(\d{4}$)/gi, "$1-$2");
  }

  if (phone.length === 10) {
    return phone.replace(/(^\d{2})(\d{4})(\d{4}$)/gi, "($1) $2-$3");
  }

  if (phone.length === 11) {
    return phone.replace(/(^\d{2})(\d{4,5})(\d{4}$)/gi, "($1) $2-$3");
  }

  if (phone.length === 12) {
    return phone.replace(/(^\d{3})(\d{5})(\d{4}$)/gi, "$1 $2-$3");
  }

  var re = new RegExp("([0-9]{" + countryCodeLength + "})([0-9][0-9])([0-9]{5})([0-9]{4})", "gi");
  return phone.replace(re, "+$1 $2 $3-$4");
};

export { formatToBRL, formatToCEP, formatToCNPJ, formatToCPF, formatToCPFOrCNPJ, formatToCapitalized, formatToDate, formatToDateTime, formatToGenericPhone, formatToList, formatToNumber, formatToPhone, formatToRG, isCEP, isCNPJ, isCPF, isCPFOrCNPJ, isDDD, isDate, isPhone, parseToArray, parseToDate, parseToNumber };
